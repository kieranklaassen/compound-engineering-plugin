# Upstream Sync Plan: compound-engineering-plugin

## Problem Statement

Your fork (`aviflombaum/compound-engineering-plugin`) has structural changes that enable configurable component loading via:
- `_source/` directory containing all agents, commands, skills
- `bin/build` Ruby script that copies enabled components based on `compound.config.json`
- `/compound:configure` interactive command for selecting components

The upstream (`EveryInc/compound-engineering-plugin`) continues to evolve the actual skill/agent/command content, but stores files directly in `agents/`, `commands/`, `skills/` without the `_source/` indirection.

**Goal:** Sync upstream content changes into your `_source/` directory while preserving your structural additions.

---

## Current State

### Your Fork Structure
```
plugins/compound-engineering/
├── _source/              # YOUR ADDITION - source of truth
│   ├── agents/
│   ├── commands/
│   └── skills/
├── agents/               # Generated by bin/build
├── commands/             # Generated by bin/build
├── skills/               # Generated by bin/build
├── bin/build             # YOUR ADDITION
├── compound.config.json  # YOUR ADDITION
└── compound.config.schema.json
```

### Upstream Structure
```
plugins/compound-engineering/
├── agents/               # Source of truth (no _source)
├── commands/
├── skills/
└── (no build system)
```

### Divergence Summary

| Type | Status |
|------|--------|
| Modified | 14 files (content updates in existing agents/commands/skills) |
| Added upstream | 3 files (`learnings-researcher.md`, `brainstorm.md`, `brainstorming/SKILL.md`) |
| Deleted upstream | 1 file (`configure.md` - makes sense, you have your own) |

---

## Proposed Solution: `sync-upstream` Shell Script + Skill

### Approach

Create a shell script (`bin/sync-upstream`) that:
1. Fetches upstream changes
2. Diffs upstream content paths against your `_source/` paths
3. Presents changes for review/approval
4. Applies approved changes to `_source/`
5. Runs `bin/build` to regenerate output directories

### Why a Script vs Git Merge

A traditional `git merge upstream/main` would:
- Conflict on every file due to different paths (`agents/` vs `_source/agents/`)
- Require manual path remapping for every file
- Break on your structural additions

A dedicated sync script can:
- Map paths intelligently (`agents/x.md` → `_source/agents/x.md`)
- Show semantic diffs (content changes only)
- Handle new files, modified files, and deletions separately
- Preserve your build infrastructure

---

## Implementation Plan

### Component 1: `bin/sync-upstream` Shell Script

```bash
#!/bin/bash
# Syncs upstream content changes to _source directory

UPSTREAM_REMOTE="upstream"
UPSTREAM_BRANCH="main"
PLUGIN_DIR="plugins/compound-engineering"
SOURCE_DIR="_source"

# Paths to sync (upstream path → local _source path)
SYNC_PATHS=(
  "agents:agents"
  "commands:commands"
  "skills:skills"
)
```

**Script Phases:**

1. **Fetch upstream** - `git fetch upstream`

2. **Detect changes** - For each component type:
   ```bash
   git diff main upstream/main --name-status -- "plugins/compound-engineering/agents/"
   ```

3. **Categorize changes:**
   - `A` (Added) → New file in upstream, needs to be added to `_source/`
   - `M` (Modified) → Content changed, show diff, apply to `_source/`
   - `D` (Deleted) → Removed upstream, prompt to remove from `_source/`

4. **Interactive review** - For each change:
   - Show the diff
   - Prompt: `Apply this change? [y/n/d(iff)/s(kip all)]`

5. **Apply changes:**
   ```bash
   # For modified/added files, extract from upstream and copy
   git show upstream/main:$UPSTREAM_PATH > $SOURCE_PATH
   ```

6. **Rebuild** - Run `bin/build` to regenerate output directories

### Component 2: Skill Definition (`skills/sync-upstream/SKILL.md`)

```markdown
---
name: sync-upstream
description: This skill should be used when the user wants to sync changes
  from the upstream EveryInc/compound-engineering-plugin repository while
  preserving local structural changes like the _source directory and build system.
---

# Sync Upstream Changes

## When to Use
- After upstream releases new versions
- When you notice upstream has new agents/commands/skills
- Periodically (e.g., weekly) to stay current

## Process

1. Run the sync script:
   ```bash
   ./plugins/compound-engineering/bin/sync-upstream
   ```

2. Review each change interactively

3. After sync completes, test the build:
   ```bash
   ./plugins/compound-engineering/bin/build
   ```

4. Commit the changes with message format:
   ```
   Sync upstream changes from EveryInc/compound-engineering-plugin

   Updated: [list modified files]
   Added: [list new files]
   Removed: [list deleted files]
   ```
```

### Component 3: Path Mapping Logic

Key insight: Upstream paths map to your `_source/` paths with a simple prefix:

| Upstream Path | Your Path |
|---------------|-----------|
| `plugins/compound-engineering/agents/review/x.md` | `plugins/compound-engineering/_source/agents/review/x.md` |
| `plugins/compound-engineering/commands/y.md` | `plugins/compound-engineering/_source/commands/y.md` |
| `plugins/compound-engineering/skills/z/SKILL.md` | `plugins/compound-engineering/_source/skills/z/SKILL.md` |

The script needs to:
1. Strip `plugins/compound-engineering/` prefix from upstream paths
2. Check if path starts with `agents/`, `commands/`, or `skills/`
3. Prepend `_source/` to create local path
4. Preserve subdirectory structure (`agents/review/`, `commands/workflows/`, etc.)

---

## Edge Cases to Handle

### 1. Your Custom Files
- `configure.md` exists in your `_source/commands/` but was deleted upstream
- Solution: Skip files that only exist locally (inverse of normal sync)

### 2. Conflicting Changes
- Both you and upstream modified the same file
- Solution: Show both versions, let user pick or merge manually

### 3. Skill Directory Structure
- Skills have subdirectories (`references/`, `assets/`, `scripts/`)
- Solution: Sync entire skill directory, not just SKILL.md

### 4. Binary Files
- Skills may include images in `assets/`
- Solution: Copy without diffing for binary files

---

## Script Pseudocode

```bash
#!/bin/bash
set -e

PLUGIN_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
SOURCE_DIR="$PLUGIN_ROOT/_source"

# Ensure upstream remote exists
if ! git remote get-url upstream &>/dev/null; then
  git remote add upstream https://github.com/EveryInc/compound-engineering-plugin.git
fi

git fetch upstream

echo "Analyzing upstream changes..."

# Get list of changed files in the component directories
COMPONENTS=("agents" "commands" "skills")

for component in "${COMPONENTS[@]}"; do
  echo ""
  echo "=== $component ==="

  # Get changes for this component
  changes=$(git diff main upstream/main --name-status -- "plugins/compound-engineering/$component/")

  if [ -z "$changes" ]; then
    echo "No changes"
    continue
  fi

  while IFS=$'\t' read -r status upstream_path; do
    # Map upstream path to _source path
    local_path=$(echo "$upstream_path" | sed 's|plugins/compound-engineering/|plugins/compound-engineering/_source/|')

    case $status in
      A)
        echo "NEW: $upstream_path"
        read -p "Add this file? [y/n] " choice
        if [ "$choice" = "y" ]; then
          mkdir -p "$(dirname "$local_path")"
          git show "upstream/main:$upstream_path" > "$local_path"
        fi
        ;;
      M)
        echo "MODIFIED: $upstream_path"
        read -p "Show diff? [y/n] " choice
        if [ "$choice" = "y" ]; then
          git diff main upstream/main -- "$upstream_path"
        fi
        read -p "Apply change? [y/n] " choice
        if [ "$choice" = "y" ]; then
          git show "upstream/main:$upstream_path" > "$local_path"
        fi
        ;;
      D)
        echo "DELETED upstream: $upstream_path"
        if [ -f "$local_path" ]; then
          read -p "Also delete locally? [y/n] " choice
          if [ "$choice" = "y" ]; then
            rm "$local_path"
          fi
        fi
        ;;
    esac
  done <<< "$changes"
done

echo ""
echo "Sync complete. Running build..."
"$PLUGIN_ROOT/bin/build"
```

---

## Alternative Approaches Considered

### 1. Git Subtree
- Could treat upstream as a subtree
- Problem: Path mismatch (`agents/` vs `_source/agents/`) makes this messy

### 2. Git Submodule for Upstream
- Keep upstream as a submodule, copy to `_source/` on build
- Problem: Two copies of everything, confusing

### 3. Cherry-pick Commits with Path Rewriting
- `git format-patch` + `git am` with path filters
- Problem: Commits may touch multiple files with mixed relevance

### 4. Periodic Manual Sync
- Just manually copy changed files
- Problem: Error-prone, easy to miss changes

**Chosen approach (sync script)** is the best balance of:
- Automation (no manual file copying)
- Control (interactive review of each change)
- Simplicity (bash script, no complex git machinery)

---

## Success Criteria

1. Script correctly maps all upstream paths to `_source/` equivalents
2. New upstream files are added to `_source/`
3. Modified files show meaningful diffs
4. Deleted files are handled gracefully
5. Your custom additions (`configure.md`, `bin/build`, etc.) are preserved
6. `bin/build` runs successfully after sync
7. Plugin loads correctly after rebuild

---

## Next Steps

1. **Review this plan** - Any edge cases I missed?
2. **Implement `bin/sync-upstream`** - The shell script
3. **Add skill definition** - For documentation
4. **Test with current divergence** - The 14 modified + 3 added files
5. **Document in README** - How to keep fork up to date
